<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://leak.syru.dev/blog</id>
    <title>시루의 하루들 Blog</title>
    <updated>2025-12-30T18:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://leak.syru.dev/blog"/>
    <subtitle>시루의 하루들 Blog</subtitle>
    <icon>https://leak.syru.dev/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[2025 경기대학교 해킹방어대회 출제 후기]]></title>
        <id>https://leak.syru.dev/blog/kctf-2025_review</id>
        <link href="https://leak.syru.dev/blog/kctf-2025_review"/>
        <updated>2025-12-30T18:00:00.000Z</updated>
        <summary type="html"><![CDATA[모교인 경기대학교에선 매년 연말에 전산정보원과 K.Knock이 협업하여 해킹방어대회를 개최한다.]]></summary>
        <content type="html"><![CDATA[<p>모교인 경기대학교에선 매년 연말에 전산정보원과 K.Knock이 협업하여 해킹방어대회를 개최한다.</p>
<p>나는 정회원이 된 이후로 군 복무 시절을 제외하고 매년 문제를 출제하고 있는데 올해는 원래 XSS 문제를 내려고 했다.</p>
<p>그렇게 어떤 컨셉으로 낼지 고민하던 와중에 12월 4일 React2Shell이라는 엄청난 사건이 발생해버렸다.</p>
<p>Log4j 만한 큰 사건이지만 심지어 exploit이 훨씬 간단하여 이건 문제로 꼭 내야겠다고 다짐하게된다.</p>
<p>거기에 간단한 점수 주기 문제 하나 더해서 두 문제를 출제하게되었다.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="welcome-misc">Welcome (Misc)<a href="https://leak.syru.dev/blog/kctf-2025_review#welcome-misc" class="hash-link" aria-label="Direct link to Welcome (Misc)" title="Direct link to Welcome (Misc)" translate="no">​</a></h2>
<blockquote>
<p>실수로 난이도가 더 내려가버렸는데 왜 안 풀리지?</p>
</blockquote>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="결과">결과<a href="https://leak.syru.dev/blog/kctf-2025_review#%EA%B2%B0%EA%B3%BC" class="hash-link" aria-label="Direct link to 결과" title="Direct link to 결과" translate="no">​</a></h3>
<p>820점 (7 Solves)</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="출제-의도">출제 의도<a href="https://leak.syru.dev/blog/kctf-2025_review#%EC%B6%9C%EC%A0%9C-%EC%9D%98%EB%8F%84" class="hash-link" aria-label="Direct link to 출제 의도" title="Direct link to 출제 의도" translate="no">​</a></h3>
<p>요즘 모의해킹 업무를 수행하다보면 전통적인 취약점의 발견 빈도가 많이 낮아진게 느껴진다.</p>
<p>그래도 뚫어야한다는 마음가짐으로 다양한 방향으로 파고들다보면 OSINT 기법을 활용하게 되는데 나는 그 중에서 깃허브를 활용한 정보 탐색을 참 애용한다.</p>
<p>그래서 내 포트폴리오 사이트 내 숨어있는 플래그를 찾아보도록 문제를 내었다.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="의도한-풀이-방향">의도한 풀이 방향<a href="https://leak.syru.dev/blog/kctf-2025_review#%EC%9D%98%EB%8F%84%ED%95%9C-%ED%92%80%EC%9D%B4-%EB%B0%A9%ED%96%A5" class="hash-link" aria-label="Direct link to 의도한 풀이 방향" title="Direct link to 의도한 풀이 방향" translate="no">​</a></h3>
<ol>
<li class="">포트폴리오 사이트 접근 후 소스코드 확인 (<code>view-source:https://leak.syru.dev</code> or DevTools)</li>
<li class="">Docusaurus 사용하여 제작된 사이트임을 파악<!-- -->
<div class="language-html codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-html codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">meta</span><span class="token tag" style="color:#00009f"> </span><span class="token tag attr-name" style="color:#00a4db">name</span><span class="token tag attr-value punctuation attr-equals" style="color:#393A34">=</span><span class="token tag attr-value punctuation" style="color:#393A34">"</span><span class="token tag attr-value" style="color:#e3116c">generator</span><span class="token tag attr-value punctuation" style="color:#393A34">"</span><span class="token tag" style="color:#00009f"> </span><span class="token tag attr-name" style="color:#00a4db">content</span><span class="token tag attr-value punctuation attr-equals" style="color:#393A34">=</span><span class="token tag attr-value punctuation" style="color:#393A34">"</span><span class="token tag attr-value" style="color:#e3116c">Docusaurus v2.3.0</span><span class="token tag attr-value punctuation" style="color:#393A34">"</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><br></span></code></pre></div></div>
</li>
<li class="">Docusaurus에 대해 찾아보고 정적 사이트 생성기라는 정보를 확인</li>
<li class="">정적 사이트에 대해 찾아보고 깃허브를 통해 배포하는 방법 확인</li>
<li class="">깃허브 검색 기능을 통해 <code>leak.syru.dev</code>를 검색하여 정적 사이트 배포중인 리포지토리 발견<!-- -->
<ul>
<li class=""><code>https://github.com/l0vey0u/l0vey0u.github.io</code></li>
</ul>
</li>
<li class="">리포지토리 확인 중 <strong>2048</strong>이란 수상한 경로 발견 (사이트 단순 탐색으론 발견 불가)</li>
<li class=""><code>https://leak.syru.dev/2048</code>로 접근, 2048 게임 확인</li>
<li class="">소스코드 확인 후 주석 처리된 플래그 확인</li>
</ol>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="여담">여담<a href="https://leak.syru.dev/blog/kctf-2025_review#%EC%97%AC%EB%8B%B4" class="hash-link" aria-label="Direct link to 여담" title="Direct link to 여담" translate="no">​</a></h3>
<p>깃허브를 찾는게 가장 중요한 문제였는데 내 포폴에 깃허브 링크가 주어져있다는 것을 잊어버렸다,,,</p>
<p>처음에 <code>/2048</code>을 힌트로 설정했다가 너무 의미가 없는 문제가 될 것 같아 <code>#osint #github</code>로 바꾸었는데 다수의 풀이 방향이 <code>Junior developer's mistake</code>문제와 동일하게 되어 재미도 없고 의미도 없는 문제가 된 것 같다. (허무함을 느낀 사람도 있더라 ㅠㅠ)</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="facescore-web">FaceScore (Web)<a href="https://leak.syru.dev/blog/kctf-2025_review#facescore-web" class="hash-link" aria-label="Direct link to FaceScore (Web)" title="Direct link to FaceScore (Web)" translate="no">​</a></h2>
<blockquote>
<p>AI (아님)</p>
</blockquote>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="결과-1">결과<a href="https://leak.syru.dev/blog/kctf-2025_review#%EA%B2%B0%EA%B3%BC-1" class="hash-link" aria-label="Direct link to 결과" title="Direct link to 결과" translate="no">​</a></h3>
<p>920점 (5 Solves)</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="출제-의도-1">출제 의도<a href="https://leak.syru.dev/blog/kctf-2025_review#%EC%B6%9C%EC%A0%9C-%EC%9D%98%EB%8F%84-1" class="hash-link" aria-label="Direct link to 출제 의도" title="Direct link to 출제 의도" translate="no">​</a></h3>
<p>Log4j와 react2shell는 미리 막을 수 없었다는 공통점이 있다. 모듈화와 의존성의 시대에서 개발자가 아무리 잘 막아도 취약점이 발생할 수 있다는 것을 보여주는 사례이기도 하다. 그래서 CERT가 중요한 것 같다. 지인들 중 연말에 때아닌 야근, 주말 근무를 하며 눈물 흘리던 모습이 새록새록하다.</p>
<p>서두에서 말했듯 react2shell의 강력함을 체감시켜주기 위한 이 문제의 컨셉은 취약하지 않은 서비스와 취약 버전(15.1.0)의 Next.js 프레임워크였다.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="의도한-풀이-방향-1">의도한 풀이 방향<a href="https://leak.syru.dev/blog/kctf-2025_review#%EC%9D%98%EB%8F%84%ED%95%9C-%ED%92%80%EC%9D%B4-%EB%B0%A9%ED%96%A5-1" class="hash-link" aria-label="Direct link to 의도한 풀이 방향" title="Direct link to 의도한 풀이 방향" translate="no">​</a></h3>
<ol>
<li class="">Burpsuite를 통해 프록시를 잡고 해당 서비스를 이용한다. (사진을 업로드 하여 Server Action이 사용되는 얼굴 평가를 받는다.)</li>
<li class=""><code>POST /</code> 웹 요청을 보면 Next-Action 헤더를 통해 Next.js에서 Server Action이 사용되고 있는 것을 확인할 수 있다. 또한 <code>$K1</code> 표현식을 통해 Flight 프로토콜을 이용한 직렬화가 수행되고 있음을 볼 수 있다. 이를 통해 현재 해당 서비스에서 react2shell 취약점이 발생할 수 있다고 추측할 수 있다.<!-- -->
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">POST / HTTP/1.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Host: kknock.org:10010</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Length: 126239</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Next-Action: 608e49ccb4089e3d50cfca3a2ab71eea561c1f5c79</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Accept-Language: ko-KR,ko;q=0.9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Accept: text/x-component</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryopzYToGMpm6ZnyAh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Next-Router-State-Tree: %5B%22%22%2C%7B%22children%22%3A%5B%22__PAGE__%22%2C%7B%7D%2C%22%2F%22%2C%22refresh%22%5D%7D%2Cnull%2Cnull%2Ctrue%5D</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Origin: http://kknock.org:10010</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Referer: http://kknock.org:10010/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Accept-Encoding: gzip, deflate, br</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Connection: keep-alive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------WebKitFormBoundaryopzYToGMpm6ZnyAh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Disposition: form-data; name="1_score"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------WebKitFormBoundaryopzYToGMpm6ZnyAh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Disposition: form-data; name="1_comment"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">오늘 미모… 반칙</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------WebKitFormBoundaryopzYToGMpm6ZnyAh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Disposition: form-data; name="1_image"; filename="share.webp"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Type: image/webp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">... 사진 데이터 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------WebKitFormBoundaryopzYToGMpm6ZnyAh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Disposition: form-data; name="0"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[{"ok":false,"message":""},"$K1"]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------WebKitFormBoundaryopzYToGMpm6ZnyAh--</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre></div></div>
</li>
<li class="">물론 react2shell의 사전 지식이 없어 요청에서 얻을 수 있는 정보를 지나칠 수 있다. 하지만 응답을 확인해보면 Next.js 프레임워크를 사용한다는 것을 확실하게 알 수 있는데 현재 <code>next.js 취약점</code>을 구글에 치면 많은 글이 react2shell 취약점을 다루고 있다. 여러 <a href="https://zi-en.io/resources/tech/118" target="_blank" rel="noopener noreferrer" class="">react2shell 취약점 연구 글</a>을 읽어서 해당 취약점을 이해하면 된다.<!-- -->
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">HTTP/1.1 200 OK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Vary: RSC, Next-Router-State-Tree, Next-Router-Prefetch, Next-Router-Segment-Prefetch, Accept-Encoding</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Cache-Control: no-cache, no-store, max-age=0, must-revalidate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x-action-revalidated: [[],0,0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x-nextjs-cache: HIT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x-nextjs-prerender: 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">X-Powered-By: Next.js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Type: text/x-component</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Date: Wed, 24 Dec 2025 20:40:32 GMT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Connection: keep-alive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Keep-Alive: timeout=5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Length: 79</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0:{"a":"$@1","f":"","b":"KsN3asGDaFsh3Eaiu0hZJ"}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1:{"ok":true,"id":"S8dBe100"}</span><br></span></code></pre></div></div>
</li>
<li class="">버전 정보 노출이 발생한 것은 아니기 때문에 아직 확실히 취약점이 존재하는지는 알 수 없다. 취약 버전을 사용하는지 이를 통해 취약점이 발생할 확률이 있는지를 간단히 확인하기 위해 React2Shell Scanner를 활용할 수 있다. ZIEN에서 개발한 <a href="https://react2shell-scanner.zi-en.io/" target="_blank" rel="noopener noreferrer" class="">React2Shell 스캐너</a>를 통해 스캔해보면 취약점이 존재하는 것을 확인 할 수 있다.
<img decoding="async" loading="lazy" alt="react2shell_scan_result_using_zien_r2s_scanner" src="https://leak.syru.dev/assets/images/react2shell_scanner_result-f59865723b22ffe57e3e5065c0d7e7c7.png" width="1526" height="797" class="img_ev3q"></li>
<li class="">짱짱 지엔 스캐너는 심지어 HTTP 요청 / 응답도 보여주는데 유효하지 않은 Action ID에 대해서 <code>Server action not found.</code> 응답이 아닌 서버 에러가 응답되는걸로 현재 사용중인 Next.js버전이 React2Shell에 취약한 것을 확인할 수 있다. (부연설명을 짤막하게 하자면 해당 서버에러는 <code>{}</code>에 없는 속성 <code>"zi"</code>에 대해 접근하여 <code>undefined</code>이 된 후 <code>undefined</code>의 속성을 읽으려다 발생한 것이다.)
<img decoding="async" loading="lazy" alt="react2shell_scan_result_using_zien_r2s_scanner" src="https://leak.syru.dev/assets/images/react2shell_scanner_result_detail-8a9fdc56b072f59265158ed191831457.png" width="1476" height="966" class="img_ev3q"></li>
<li class="">이제 이 취약점을 이용할 차례다, CVE-2025-55182 PoC를 검색해보면 <a href="https://github.com/Malayke/Next.js-RSC-RCE-Scanner-CVE-2025-66478?tab=readme-ov-file#payload-that-can-see-command-execution-result-in-response-body-most-useful" target="_blank" rel="noopener noreferrer" class="">수 많은 페이로드</a>가 나오는데 그 중 하나를 가져다 쓰면 된다. 사진 내 간단 설명에서 react2shell의 취약점 체인 3개 중 가장 중요한 then 부분을 과감히 생략했는데 사실 생략하면 안된다. 하지만 이것만 다뤄도 현재 이 글의 분량정도 될 것 같아서 <a href="https://zi-en.io/resources/tech/118" target="_blank" rel="noopener noreferrer" class="">지엔</a>이나 <a href="https://www.enki.co.kr/media-center/blog/complete-analysis-of-the-react2shell-cve-2025-55182-vulnerability" target="_blank" rel="noopener noreferrer" class="">엔키 연구 글</a>에서 잘 다루고 있으니 참고하면 좋을 것 같다.
<img decoding="async" loading="lazy" alt="react2shell_exploit_result_and_detail" src="https://leak.syru.dev/assets/images/exploit_detail-48a0ba2f02d9c72e76273533f36bdb14.png" width="1758" height="1092" class="img_ev3q"></li>
</ol>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="여담-1">여담<a href="https://leak.syru.dev/blog/kctf-2025_review#%EC%97%AC%EB%8B%B4-1" class="hash-link" aria-label="Direct link to 여담" title="Direct link to 여담" translate="no">​</a></h3>
<p>AI라는 키워드가 핫하니까 가져다 쓴건데 업로드 된 사진들을 보니 LLM을 속이는 사진을 올린게 많이 발견되었다. 속이려고 한 건 아닌데 미안하게 되었다 허허,,, 점수는 서버에서 80~100 랜덤으로 주도록 했고 아이돌 팬의 시선으로 아이돌 사진이 많이 올라올 줄 알았는데 의문의 두쫀쿠 군단을 맞이하게 되었다. 잘 만든 서비스 같아서 내년 문제에도 가져다 쓸 것 같은데 그 땐 진짜 LLM을 도입하면 더 재밌을지도 모르겠다 ㅎㅎ</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">❯ find data/shares -maxdepth 1 -type f | wc -l # 총 제출된 사진 수</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">238</span><br></span></code></pre></div></div>]]></content>
        <author>
            <name>SYRU</name>
            <uri>https://github.com/l0vey0u</uri>
        </author>
        <category label="research" term="research"/>
        <category label="ctf" term="ctf"/>
        <category label="react2shell" term="react2shell"/>
        <category label="osint" term="osint"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docusaurus 삽질 기록]]></title>
        <id>https://leak.syru.dev/blog/memo_docusaurus</id>
        <link href="https://leak.syru.dev/blog/memo_docusaurus"/>
        <updated>2022-04-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[현재 이 사이트의 엔진인 Docusaurus를 사용하면서 한 많은 삽질을 기록할 예정이다.]]></summary>
        <content type="html"><![CDATA[<p>현재 이 사이트의 엔진인 Docusaurus를 사용하면서 한 많은 삽질을 기록할 예정이다.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="blog-글-전체를-보여줄-필요는-없는데">Blog 글 전체를 보여줄 필요는 없는데...!<a href="https://leak.syru.dev/blog/memo_docusaurus#blog-%EA%B8%80-%EC%A0%84%EC%B2%B4%EB%A5%BC-%EB%B3%B4%EC%97%AC%EC%A4%84-%ED%95%84%EC%9A%94%EB%8A%94-%EC%97%86%EB%8A%94%EB%8D%B0" class="hash-link" aria-label="Direct link to Blog 글 전체를 보여줄 필요는 없는데...!" title="Direct link to Blog 글 전체를 보여줄 필요는 없는데...!" translate="no">​</a></h3>
<div class="language-html codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-html codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">&lt;!--truncate--&gt;</span><br></span></code></pre></div></div>
<p>해당 태그를 삽입하면 블로그 글 목록과 그 내용이 출력될 때 이 태그 위까지를 미리보기 형태로 제공하며 나머지 내용은 가려진다.</p>]]></content>
        <author>
            <name>SYRU</name>
            <uri>https://github.com/l0vey0u</uri>
        </author>
        <category label="memo" term="memo"/>
        <category label="docs" term="docs"/>
        <category label="docusaurus" term="docusaurus"/>
        <category label="api" term="api"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[웹 다시 살펴보기 (1)]]></title>
        <id>https://leak.syru.dev/blog/re-zero-web-pt1</id>
        <link href="https://leak.syru.dev/blog/re-zero-web-pt1"/>
        <updated>2022-04-07T18:00:00.000Z</updated>
        <summary type="html"><![CDATA[그 동안 웹 서비스 보안 취약점을 공부하고 활용할 때 마다 내가 웹에 대해 궁금하지만 바빠서 넘어갔던 부분이 많았다.]]></summary>
        <content type="html"><![CDATA[<p>그 동안 웹 서비스 보안 취약점을 공부하고 활용할 때 마다 내가 웹에 대해 궁금하지만 바빠서 넘어갔던 부분이 많았다.
이제 좀 여유를 찾아서 궁금증도 해소하면서 웹에 대해 조금 더 이해하는 시간을 가져볼까 한다.
드림핵의 웹 서비스 보안 커리큘럼을 학습하면서 단어나 문장에 생긴 궁금점을 적어두고 이에 대해 알아보고 정리해보는 방식으로 할 생각이다.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="url과-uri">URL과 URI<a href="https://leak.syru.dev/blog/re-zero-web-pt1#url%EA%B3%BC-uri" class="hash-link" aria-label="Direct link to URL과 URI" title="Direct link to URL과 URI" translate="no">​</a></h2>
<p>URL과 URI는 각각 <a href="https://www.rfc-editor.org/rfc/rfc1738" target="_blank" rel="noopener noreferrer" class="">RFC1738</a> 와 <a href="https://www.rfc-editor.org/rfc/rfc3986" target="_blank" rel="noopener noreferrer" class="">RFC3986</a>에 정의되어있다.</p>
<p>어찌보면 같은 의미의 단어가 3개나 (+URN, 실제론 별로 안쓰니 내용엔 포함하지 않겠다) 있고 그것이 계속 유지되었다는 것은 각각이 상징적인 의미를 가지고 있다고 볼 수 있다.
다행히도 <a href="https://www.rfc-editor.org/rfc/rfc3986#section-1.1.3" target="_blank" rel="noopener noreferrer" class="">RFC3986 1.1.3 항목</a>에서 이 내용이 이미 소개되어있다.
URI가 더 포괄적인 Identifier로서의 의미를 가지고 URL과 URN으로 분류될 수 있다. URN은 constant한 name으로서, URL은 locator로서의 의미를 가진다.</p>
<p>URI는 포괄적으로 쓰기 좋은 단어라고 할 때 URL이라고 하면 안되는 URI는 무엇일까? URL을 더 파고들어가보자
URL은 특정 자원의 위치와 접근에 대한 정보를 담은 문자열이다. 특정 자원의 위치를 가리키지 못하면 URL이 아니다. 예를 들어 현재시간을 출력하는 api 주소가 있다고 하자 해당 URI는 URL도 URN도 될 수 없다. 특정 자원과 관련이 없기 때문이다. 이에 따른 논의는 더 될 수 있을 것 같다. 시간이란 것도 자원으로 해석될 수 있다고 본다. 하지만 일반적인 상황에서는 그냥 URI라고 하면 된다.</p>
<p>URN은 무엇인지 궁금해서 chatgpt를 활용해서 살펴보았다. URN은 urn:ietf:rfc:1738과 같이 인터넷 상 문서나 urn:isbn:~ 과 같은 isbn번호 같은 조금은 더 포괄적으로 자원의 이름에 대한 정보로 쓰는 문자열이다. 하지만 일반적으론 잘 안 쓰니 알고만 있으면 될 것 같다.</p>
<hr>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="reference">Reference<a href="https://leak.syru.dev/blog/re-zero-web-pt1#reference" class="hash-link" aria-label="Direct link to Reference" title="Direct link to Reference" translate="no">​</a></h3>
<ul>
<li class=""><a href="https://www.rfc-editor.org/rfc/rfc1738" target="_blank" rel="noopener noreferrer" class="">RFC1738</a></li>
<li class=""><a href="https://www.rfc-editor.org/rfc/rfc3986" target="_blank" rel="noopener noreferrer" class="">RFC3986</a></li>
</ul>]]></content>
        <author>
            <name>SYRU</name>
            <uri>https://github.com/l0vey0u</uri>
        </author>
        <category label="research" term="research"/>
        <category label="web" term="web"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[재밌는 HTTP Request Smuggling 이야기 (2)]]></title>
        <id>https://leak.syru.dev/blog/funny-smuggling-story-pt2</id>
        <link href="https://leak.syru.dev/blog/funny-smuggling-story-pt2"/>
        <updated>2022-03-06T18:00:00.000Z</updated>
        <summary type="html"><![CDATA[안녕하세요 : ) 시루입니다.]]></summary>
        <content type="html"><![CDATA[<p>안녕하세요 : ) 시루입니다.</p>
<p><a class="" href="https://leak.syru.dev/blog/funny-smuggling-story-pt1">저번 글</a>에서는 HTTP Request Smuggling이 무엇인지에 대해서 알려드렸는데요.</p>
<p>오늘은 우리 주변에 사용되는 프로그램에서 이 기법으로 공격이 가능한 취약점이 발생한 사례를 알아보겠습니다.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="잠깐-http-request-smuggling이-뭐였지">잠깐, HTTP Request Smuggling이 뭐였지?<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt2#%EC%9E%A0%EA%B9%90-http-request-smuggling%EC%9D%B4-%EB%AD%90%EC%98%80%EC%A7%80" class="hash-link" aria-label="Direct link to 잠깐, HTTP Request Smuggling이 뭐였지?" title="Direct link to 잠깐, HTTP Request Smuggling이 뭐였지?" translate="no">​</a></h2>
<p>사례 연구에 앞서 복습을 해봅시다.</p>
<p>이 공격 기법은 HTTP 요청이 처리될 때 이전 요청이 다음 요청에 포함되어 해당 요청의 처리결과를 바꾸는 것이었습니다.</p>
<p>웹 서비스 인프라를 구성할 때 트래픽 분산, 캐싱 등을 위해 프록시를 배치하게 되는데 이 프록시와 웹 서버가 서로 HTTP 요청의 Body 길이에 대한 해석을 다르게 하면서 주로 발생합니다.</p>
<p>Body의 길이는 Content-Length 헤더나 Transfer-Encoding 헤더를 통해 결정되며 아래의 규칙이 존재합니다.</p>
<ol>
<li class="">Content-Length 헤더가 2개 이상 존재하면 400 Bad Request로 처리한다.</li>
<li class="">Content-Length 헤더와 Transfer-Encoding 헤더가 동시에 존재하면 Transfer-Encoding을 따른다.</li>
</ol>
<p>규칙을 읽어보면 표준에 따르기만 해도 Smuggling이 방지될 것 같습니다.</p>
<p>하지만 공격자들은 연구 끝에 아래 방법을 사용하여 이를 우회 하였습니다.</p>
<ol>
<li class="">특수한 입력값을 통해 특정 파서의 파싱 결과를 다르게 나오도록 유도하기</li>
<li class="">파서의 잘못된 처리로직을 이용하기</li>
</ol>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="공격-사례">공격 사례<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt2#%EA%B3%B5%EA%B2%A9-%EC%82%AC%EB%A1%80" class="hash-link" aria-label="Direct link to 공격 사례" title="Direct link to 공격 사례" translate="no">​</a></h2>
<p>편의를 위해 Content-Length를 CL, Transfer-Encoding을 TE라고 부르겠습니다.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="cl-cl--특정-파서의-파싱-결과를-다르게-나오도록-유도하기">CL-CL + 특정 파서의 파싱 결과를 다르게 나오도록 유도하기<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt2#cl-cl--%ED%8A%B9%EC%A0%95-%ED%8C%8C%EC%84%9C%EC%9D%98-%ED%8C%8C%EC%8B%B1-%EA%B2%B0%EA%B3%BC%EB%A5%BC-%EB%8B%A4%EB%A5%B4%EA%B2%8C-%EB%82%98%EC%98%A4%EB%8F%84%EB%A1%9D-%EC%9C%A0%EB%8F%84%ED%95%98%EA%B8%B0" class="hash-link" aria-label="Direct link to CL-CL + 특정 파서의 파싱 결과를 다르게 나오도록 유도하기" title="Direct link to CL-CL + 특정 파서의 파싱 결과를 다르게 나오도록 유도하기" translate="no">​</a></h3>
<p>HAProxy는 고가용성(HA)을 위해 주로 사용되는 프록시 입니다.</p>
<p>작년 9월에 이 프록시에서 CL-CL 유형의 HTTP Request Smuggling이 발견되었습니다.</p>
<p>해당 유형이 동작하려면 두 파싱 단계에서 400 bad request 처리를 막아야합니다.</p>
<p>즉 처리하는 순간에는 CL 헤더는 하나만 있는 것으로 보여야 합니다.</p>
<p>해당 취약 버젼에서 HAProxy는 파싱단계에서 CL이 한번 정상적으로 처리되면 나머지 헤더는 무시하도록 프로그래밍 되어 있습니다.</p>
<p>그렇기에 HAProxy가 웹 서버로 전달하는 HTTP 요청에는 CL 헤더가 하나만 존재하게 됩니다.</p>
<p>지금까지의 내용을 정리하면 대략 아래와 같은 방식으로 공격을 진행하면 됩니다.</p>
<p><img decoding="async" loading="lazy" src="https://leak.syru.dev/assets/images/attack_flow-fcd6bf53a3235fbc01b1fbf673f1220b.png" width="2522" height="452" class="img_ev3q"></p>
<p>그럼 이제 HAProxy가 전달받은 HTTP 요청이 400 Bad Request가 안 뜨면서 두 번째 요청의 CL 헤더의 값과 다르게 하려면 어떻게 해야 할까요?</p>
<p>HAProxy가 파싱과정에서 비정상 헤더를 정상으로 만들면 됩니다.</p>
<p>HAProxy는 HTTP 요청을 파싱할 때 HTX라는 구조를 사용합니다.</p>
<p>HTX는 크게 실제 데이터가 들어있는 payload와 해당 정보를 저장하는 block으로 나뉩니다.</p>
<p>block에는 이 정보가 어떤 payload의 것인지 주소를 저장하는 부분과 해당 payload의 정보를 저장하는 부분으로 나뉩니다.</p>
<p>HTX_BLOCK 구조의 두 멤버는 모두 uint32 (4byte) 자료형을 쓰고 있습니다.</p>
<p><img decoding="async" loading="lazy" src="https://leak.syru.dev/assets/images/htx_t-3e6d69f2d2f4a7851853669950be2181.png" width="3668" height="1723" class="img_ev3q"></p>
<p>payload의 정보를 저장하는 부분을 보면 헤더의 길이를 저장하는 공간이 1byte인 것을 알 수 있습니다.</p>
<p>정상적인 헤더 중 1byte(256)을 넘는 길이를 가지는 것은 없기 때문에 문제가 없어보입니다.</p>
<p>실제로 아래와 같이 주석만 남겨두고 길이 검증 코드가 존재하지 않았습니다.</p>
<div><div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockTitle_OeMC">include/haproxy/htx.h</div><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">loading</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><br></span></code></pre></div></div><div style="font-size:.9em;font-weight:600;color:#0E75DD;text-align:center;padding-bottom:13px;text-decoration:underline" class=""><a href="https://github.com/haproxy/haproxy/blob/3d5f19e04d88e7c8f71cba4ea12e383c91de89f6/include/haproxy/htx.h#L464-L470" target="_blank">View on GitHub</a></div></div>
<p>이처럼 미흡한 검증은 공격에 쓰이는 좋은 가젯이 됩니다.</p>
<p>Integer Overflow를 통해 정상 헤더 + dummy 구조의 헤더에서 정상 부분만 처리하도록 하면 우리는 비정상 헤더를 정상으로 보이게 할 수 있습니다.</p>
<p>HTX를 파싱할 때 헤더의 길이는 구분자 <code>:</code> 앞까지로 계산됩니다.</p>
<div class="language-http codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-http codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">POST / HTTP/1.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Length0aaaa..255개..aa: --- (1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Length: 4 --- (2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CLCL</span><br></span></code></pre></div></div>
<p>(1)에서 헤더의 길이는 270입니다.</p>
<p>그런데 270은 <code>0b100001110</code> 인데 공간은 8bit만 할당되어 있으므로 앞에 1은 짤려서 <code>0b00001110</code> 만 저장되게 됩니다.</p>
<p>그렇게 조작된 길이 14만큼 읽으면 정상 헤더인 <code>Content-Length</code>로 바뀌게 됩니다.</p>
<p>앞서 설명한 부분들을 정리하면 아래의 순서로 Smuggling이 발생합니다.</p>
<ol>
<li class="">
<p>해당 패킷을 HAProxy가 받을 때는 (1)은 비정상 헤더로 처리되고 (2)를 기준으로 처리</p>
</li>
<li class="">
<p>HTX 구조로 파싱할 때 Integer Overflow로 인해 (1)이 정상 헤더로 처리</p>
</li>
<li class="">
<p>HAProxy가 웹 서버에 전달할 때는 (1)이 해당 요청이 다음과 같이 바뀌어 전달</p>
<div class="language-http codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-http codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">POST / HTTP/1.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Length:0 --- (1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CLCL</span><br></span></code></pre></div></div>
</li>
<li class="">
<p>Content-Length만큼 처리 후 남은 CLCL이 다음 리퀘스트에 삽입됨</p>
</li>
</ol>
<p>이 취약점은 당연히 아래와 같이 길이 검사를 추가하는 방향으로 패치되었습니다.</p>
<div class="language-diff codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-diff codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">+ if (name.len &gt; 255 || value.len &gt; 1048575)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+     return NULL;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="cl-te--파서의-잘못된-처리-로직-이용하기">CL-TE + 파서의 잘못된 처리 로직 이용하기<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt2#cl-te--%ED%8C%8C%EC%84%9C%EC%9D%98-%EC%9E%98%EB%AA%BB%EB%90%9C-%EC%B2%98%EB%A6%AC-%EB%A1%9C%EC%A7%81-%EC%9D%B4%EC%9A%A9%ED%95%98%EA%B8%B0" class="hash-link" aria-label="Direct link to CL-TE + 파서의 잘못된 처리 로직 이용하기" title="Direct link to CL-TE + 파서의 잘못된 처리 로직 이용하기" translate="no">​</a></h3>
<p>Tomcat은 JSP를 처리하는 Web Application Server 입니다.</p>
<p>작년 7월에 tomcat에서 CL-TE 유형의 HTTP Request Smuggling 취약점이 발견되었습니다.</p>
<p>해당 버젼에서 Client가 HTTP/1.0 응답만 받아들이도록 선언되어 있으면 Tomcat이 TE 헤더를 무시하는 로직이 존재하였고 결과적으로 아래와 같이 동작하였습니다.</p>
<p><img decoding="async" loading="lazy" alt="image-20220303173216629" src="https://leak.syru.dev/assets/images/cl_te_attack_flow-dcde0f8fd5dbc7cd8f67c3df756bcaf7.png" width="2522" height="452" class="img_ev3q"></p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="마치며">마치며<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt2#%EB%A7%88%EC%B9%98%EB%A9%B0" class="hash-link" aria-label="Direct link to 마치며" title="Direct link to 마치며" translate="no">​</a></h2>
<p>HTTP Request Smuggling은 처리 방식이 동기화되지 않았다고 하여 HTTP Desync Attack이라고도 불립니다.</p>
<p>DEFCON 대회 예선 문제로 해당 취약점을 이용한 문제가 출제된 바 있으니 풀어보시면 이해하시는 데 도움이 되실 겁니다.</p>
<p><a href="https://archive.ooo/c/uploooadit/351/" target="_blank" rel="noopener noreferrer" class="">uploooadit | OOO archive | DEF CON CTF</a></p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="reference">Reference<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt2#reference" class="hash-link" aria-label="Direct link to Reference" title="Direct link to Reference" translate="no">​</a></h3>
<ul>
<li class=""><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-33037" target="_blank" rel="noopener noreferrer" class="">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-33037</a></li>
<li class=""><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-40346" target="_blank" rel="noopener noreferrer" class="">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-40346</a></li>
<li class=""><a href="https://github.com/haproxy/haproxy/commit/3b69886f7dcc3cfb3d166309018e6cfec9ce2c95#diff-8420c19f30c823a2c9cbe3ee5d35cf31550110b38fe767b620880f9cd82cecc8" target="_blank" rel="noopener noreferrer" class="">https://github.com/haproxy/haproxy/commit/3b69886f7dcc3cfb3d166309018e6cfec9ce2c95#diff-8420c19f30c823a2c9cbe3ee5d35cf31550110b38fe767b620880f9cd82cecc8</a></li>
</ul>]]></content>
        <author>
            <name>SYRU</name>
            <uri>https://github.com/l0vey0u</uri>
        </author>
        <category label="research" term="research"/>
        <category label="http" term="http"/>
        <category label="http smuggling" term="http smuggling"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[사소한 팁 들 정리]]></title>
        <id>https://leak.syru.dev/blog/memo_tips</id>
        <link href="https://leak.syru.dev/blog/memo_tips"/>
        <updated>2022-02-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[nginx - fastapi 구조의 서비스에서 왜 인지 한글 처리가 제대로 되지 않았다.]]></summary>
        <content type="html"><![CDATA[<p>nginx - fastapi 구조의 서비스에서 왜 인지 한글 처리가 제대로 되지 않았다.
charset = utf8 설정을 주어도 해결이 되지 않자</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="base64-encoding">Base64 Encoding<a href="https://leak.syru.dev/blog/memo_tips#base64-encoding" class="hash-link" aria-label="Direct link to Base64 Encoding" title="Direct link to Base64 Encoding" translate="no">​</a></h3>
<p>URL 인코딩 후 그 문자열을 base64처리하여 전달해서 해결하였다.</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">encoded_kr </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token dom variable" style="color:#36acaa">window</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">btoa</span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#d73a49">unescape</span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#d73a49">encodeURLComponent</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">kr_str</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre></div></div>
<div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">from</span><span class="token plain"> base64 </span><span class="token keyword" style="color:#00009f">import</span><span class="token plain"> b64decode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">decoded_kr </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> b64decode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">encoded_kr</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">decode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="더-알아보아야-할-점">더 알아보아야 할 점<a href="https://leak.syru.dev/blog/memo_tips#%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EC%95%84%EC%95%BC-%ED%95%A0-%EC%A0%90" class="hash-link" aria-label="Direct link to 더 알아보아야 할 점" title="Direct link to 더 알아보아야 할 점" translate="no">​</a></h3>
<p>client js 에서 전달하는 위치에선 한글이 깨졌는데 fastapi에서 전달하는 방향으론 한글이 안 깨졌다 js 쪽이 문제였나..?</p>]]></content>
        <author>
            <name>SYRU</name>
            <uri>https://github.com/l0vey0u</uri>
        </author>
        <category label="memo" term="memo"/>
        <category label="tip" term="tip"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[재밌는 HTTP Request Smuggling 이야기 (1)]]></title>
        <id>https://leak.syru.dev/blog/funny-smuggling-story-pt1</id>
        <link href="https://leak.syru.dev/blog/funny-smuggling-story-pt1"/>
        <updated>2022-02-06T18:00:00.000Z</updated>
        <summary type="html"><![CDATA[안녕하세요 : ) 시루입니다.]]></summary>
        <content type="html"><![CDATA[<p>안녕하세요 : ) 시루입니다.</p>
<p>오늘은 간단한 원리지만 불특정 다수에게 피해를 줄 수 있는 공격기법을 가져왔습니다.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="결과물이-제-요청과-달라요">결과물이 제 요청과 달라요<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt1#%EA%B2%B0%EA%B3%BC%EB%AC%BC%EC%9D%B4-%EC%A0%9C-%EC%9A%94%EC%B2%AD%EA%B3%BC-%EB%8B%AC%EB%9D%BC%EC%9A%94" class="hash-link" aria-label="Direct link to 결과물이 제 요청과 달라요" title="Direct link to 결과물이 제 요청과 달라요" translate="no">​</a></h3>
<p>설명을 위해 라벨기를 가져왔습니다. 이 라벨기는 문장과 길이를 입력하면 길이만큼 잘라 줍니다.</p>
<p>장난꾸러기 시루가 “시루반”이라는 문장을 입력해놓고 두 글자만 입력했다고 하면 어떻게 될까요?</p>
<p><img decoding="async" loading="lazy" alt="label printer image for prologue" src="https://leak.syru.dev/assets/images/label_printer_for_prologue-f0752a10bb8eaa0663f5c9e803b76b9a.png" width="2258" height="935" class="img_ev3q"></p>
<p>그다음 입력이었던 “민초단” 라벨이 “반민초”가 되어버렸습니다...!</p>
<p>이는 시루의 요청을 처리한 후 남은 ‘반’이라는 글자가 다음 요청에 포함되어 발생한 것입니다.</p>
<p>이런 일이 웹 서비스에서도 발생할 수 있습니다. 이번 글에서는 나의 요청이 타인에게 영향을 줄 수 있는 HTTP Request Smuggling을 알아보겠습니다.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="http-request-smuggling">HTTP Request Smuggling<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt1#http-request-smuggling" class="hash-link" aria-label="Direct link to HTTP Request Smuggling" title="Direct link to HTTP Request Smuggling" translate="no">​</a></h2>
<blockquote>
<p>HTTP 요청에 대한 일관성 없는 해석</p>
</blockquote>
<p><a href="https://cwe.mitre.org/data/definitions/444.html" target="_blank" rel="noopener noreferrer" class="">CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')</a></p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="동일한-tcp-connection에서-여러개의-http-message가-처리된-사연">동일한 TCP Connection에서 여러개의 HTTP Message가 처리된 사연<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt1#%EB%8F%99%EC%9D%BC%ED%95%9C-tcp-connection%EC%97%90%EC%84%9C-%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-http-message%EA%B0%80-%EC%B2%98%EB%A6%AC%EB%90%9C-%EC%82%AC%EC%97%B0" class="hash-link" aria-label="Direct link to 동일한 TCP Connection에서 여러개의 HTTP Message가 처리된 사연" title="Direct link to 동일한 TCP Connection에서 여러개의 HTTP Message가 처리된 사연" translate="no">​</a></h3>
<p>HTTP 프로토콜은 TCP 통신 위에서 동작합니다.</p>
<p>(UDP를 사용하는 HTTP 3는 이 글에선 언급하지 않겠습니다.)</p>
<p>TCP 통신은 신뢰할 수 있는 통신을 위해 여러 정보를 공유하는 3way handshake과정을 거칩니다.</p>
<p>HTTP 통신을 할 때마다 TCP 통신을 새로 해야 한다면 당연히 그만큼 handshake도 해야 하게 됩니다.</p>
<p>이 시간을 최대한 줄이기 위해 HTTP는 기존에 만들어진 TCP 통신을 사용하게 되었습니다.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="http에서-body-정보를-얻는-방법">HTTP에서 Body 정보를 얻는 방법<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt1#http%EC%97%90%EC%84%9C-body-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EC%96%BB%EB%8A%94-%EB%B0%A9%EB%B2%95" class="hash-link" aria-label="Direct link to HTTP에서 Body 정보를 얻는 방법" title="Direct link to HTTP에서 Body 정보를 얻는 방법" translate="no">​</a></h3>
<p><a href="https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.3" target="_blank" rel="noopener noreferrer" class="">RFC 문서</a>에 따르면 Body의 길이는 다음 규칙을 따릅니다.</p>
<ul>
<li class="">Transfer-Encoding 헤더가 존재하고 chunked transfer coding으로 전달될 때 transfer coding이 data 전송이 끝났음을 가리킬 때까지의 길이로 결정</li>
<li class="">Transfer-Encoding 헤더가 존재하지 않고 유효한 Content-Length 헤더가 존재할 때 해당 헤더의 값으로 결정</li>
<li class="">Transfer-Encoding 헤더와 Content-Length 헤더가 모두 존재하면 Content-Length 헤더 무시</li>
<li class="">Content-Length 헤더가 여러 개 있으면 400 Bad Request 처리</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="라벨기가-웹-서비스였다면">라벨기가 웹 서비스였다면<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt1#%EB%9D%BC%EB%B2%A8%EA%B8%B0%EA%B0%80-%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%98%80%EB%8B%A4%EB%A9%B4" class="hash-link" aria-label="Direct link to 라벨기가 웹 서비스였다면" title="Direct link to 라벨기가 웹 서비스였다면" translate="no">​</a></h3>
<p>라벨기 이야기를 웹 서비스로 확장 시켜보겠습니다.</p>
<p>라벨기 입력은 완료를 누를 때까지 입력하니 Transfer-Encoding 방식이 어울리고 라벨 커터는 입력받은 길이만큼 자르니 Content-Length가 어울리겠네요</p>
<p>라벨기에 문장을 입력하고 자르는 과정은 아래와 같이 표현할 수 있습니다.</p>
<p><img decoding="async" loading="lazy" alt="packet diagram" src="https://leak.syru.dev/assets/images/packet_diagram-dadce470f75fb9b1e3a3f4b220ba2dcf.png" width="2621" height="1271" class="img_ev3q"></p>
<p>라벨 요청에 대한 응답은 아래와 같이 표현할 수 있습니다.</p>
<p><img decoding="async" loading="lazy" alt="simplified stream" src="data:image/png;base64,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" width="1664" height="154" class="img_ev3q"></p>
<p>이렇게 된 원인이 무엇일까요? 우선 동일한 라벨카트리지(TCP 커넥션)에서 처리되었고 라벨기에서는 문자열의 끝(Transfer-Encoding)이 기준이였지만 라벨 커터에서는 길이로 입력한 값(Content-Length)이 기준이였기 때문입니다.</p>
<p>라벨 커터는 앞서 설명드린 규칙을 어긴 예시라고 볼 수도 있겠네요</p>
<p>이러한 방식으로 다른 요청에 삽입되어 해당 요청을 사용할 수 없게 하거나 완전히 다른 요청으로 바꿔버릴 수 있는 공격이 바로 <strong>HTTP Request Smuggling</strong>입니다.</p>
<p>이 공격기법은 유형이 크게 두 가지로 나뉩니다.</p>
<p>Content-Length 헤더 중복 문제 이하 CL-CL이라 부르는 유형과 Transfer-Encoding, Content-Length 헤더 혼동 문제 이하 CL-TE라고 부르는 유형입니다.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="그냥-표준만-따르면-되는-것-아닌가요">그냥 표준만 따르면 되는 것 아닌가요?<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt1#%EA%B7%B8%EB%83%A5-%ED%91%9C%EC%A4%80%EB%A7%8C-%EB%94%B0%EB%A5%B4%EB%A9%B4-%EB%90%98%EB%8A%94-%EA%B2%83-%EC%95%84%EB%8B%8C%EA%B0%80%EC%9A%94" class="hash-link" aria-label="Direct link to 그냥 표준만 따르면 되는 것 아닌가요?" title="Direct link to 그냥 표준만 따르면 되는 것 아닌가요?" translate="no">​</a></h3>
<p>맞습니다. 처리하는 주체들이 모두 동일한 기준으로 처리하면 됩니다.</p>
<p>하지만 최근 공격 유형은 요청을 파싱할 때 특정 헤더를 인식하지 못하도록 특수문자를 삽입하거나 다른 내용으로 인식하도록 Buffer Overflow 기법을 사용하는 등 규칙만 따라서는 대응하기 어려운 것이 많습니다.</p>
<p>표준을 따르는 것 외에도 기본적인 길이 검증이나 특수문자 처리등을 신경써야 합니다.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="마치며">마치며<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt1#%EB%A7%88%EC%B9%98%EB%A9%B0" class="hash-link" aria-label="Direct link to 마치며" title="Direct link to 마치며" translate="no">​</a></h2>
<p>다음 포스트에서는 실제로 취약점이 발생한 사례를 공격 유형별로 다뤄보겠습니다.</p>]]></content>
        <author>
            <name>SYRU</name>
            <uri>https://github.com/l0vey0u</uri>
        </author>
        <category label="research" term="research"/>
        <category label="http" term="http"/>
        <category label="http smuggling" term="http smuggling"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[우리가 알고있는 Underflow는 Underflow가 아니다.]]></title>
        <id>https://leak.syru.dev/blog/memo_about_underflow</id>
        <link href="https://leak.syru.dev/blog/memo_about_underflow"/>
        <updated>2020-02-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[잘 알려진 Underflow의 정의]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="잘-알려진-underflow의-정의">잘 알려진 Underflow의 정의<a href="https://leak.syru.dev/blog/memo_about_underflow#%EC%9E%98-%EC%95%8C%EB%A0%A4%EC%A7%84-underflow%EC%9D%98-%EC%A0%95%EC%9D%98" class="hash-link" aria-label="Direct link to 잘 알려진 Underflow의 정의" title="Direct link to 잘 알려진 Underflow의 정의" translate="no">​</a></h3>
<p>자료형이 저장할 수 있는 범위를 <strong>넘어서</strong> 최솟값 보다 작아지면 최댓값 부터 다시 시작되는 현상</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="이-역시-integer-overflow">이 역시 Integer Overflow<a href="https://leak.syru.dev/blog/memo_about_underflow#%EC%9D%B4-%EC%97%AD%EC%8B%9C-integer-overflow" class="hash-link" aria-label="Direct link to 이 역시 Integer Overflow" title="Direct link to 이 역시 Integer Overflow" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 32bit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-2,147,483,648 - 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">= -2,147,483,648 + (~1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0,10000000,00000000,00000000,00000000(2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0,11111111,11111111,11111111,11111111(2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1,01111111,11111111,11111111,11111111(2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">overflow 부분 제외 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">= 2,147,483,648</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="그럼-underflow는-무엇인가">그럼 Underflow는 무엇인가?<a href="https://leak.syru.dev/blog/memo_about_underflow#%EA%B7%B8%EB%9F%BC-underflow%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80" class="hash-link" aria-label="Direct link to 그럼 Underflow는 무엇인가?" title="Direct link to 그럼 Underflow는 무엇인가?" translate="no">​</a></h3>
<p>부동소수점에서 표현 가능 범위보다 작은 0에 가까운 수가 0이 되는 현상</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="integer-underflow">Integer Underflow<a href="https://leak.syru.dev/blog/memo_about_underflow#integer-underflow" class="hash-link" aria-label="Direct link to Integer Underflow" title="Direct link to Integer Underflow" translate="no">​</a></h3>
<p>설명에 편의성을 위해 Floating Underflow, Integer Underflow로 구분하여 Underflow를 쓰기도 한다.</p>]]></content>
        <author>
            <name>SYRU</name>
            <uri>https://github.com/l0vey0u</uri>
        </author>
        <category label="memo" term="memo"/>
        <category label="term" term="term"/>
        <category label="underflow" term="underflow"/>
    </entry>
</feed>