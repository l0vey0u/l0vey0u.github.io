<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.syru.dev/blog</id>
    <title>시루의 하루들 Blog</title>
    <updated>2022-03-06T18:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.syru.dev/blog"/>
    <subtitle>시루의 하루들 Blog</subtitle>
    <icon>https://www.syru.dev/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[[Research] 재밌는 HTTP Request Smuggling 이야기 (2)]]></title>
        <id>/funny-smuggling-story-pt2</id>
        <link href="https://www.syru.dev/blog/funny-smuggling-story-pt2"/>
        <updated>2022-03-06T18:00:00.000Z</updated>
        <summary type="html"><![CDATA[안녕하세요 : ) 시루입니다.]]></summary>
        <content type="html"><![CDATA[<p>안녕하세요 : ) 시루입니다.</p><p><a href="/blog/funny-smuggling-story-pt1">저번 글</a>에서는 HTTP Request Smuggling이 무엇인지에 대해서 알려드렸는데요.</p><p>오늘은 우리 주변에 사용되는 프로그램에서 이 기법으로 공격이 가능한 취약점이 발생한 사례를 알아보겠습니다.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="잠깐-http-request-smuggling이-뭐였지">잠깐, HTTP Request Smuggling이 뭐였지?<a class="hash-link" href="#잠깐-http-request-smuggling이-뭐였지" title="Direct link to heading">​</a></h2><p>사례 연구에 앞서 복습을 해봅시다.</p><p>이 공격 기법은 HTTP 요청이 처리될 때 이전 요청이 다음 요청에 포함되어 해당 요청의 처리결과를 바꾸는 것이었습니다.</p><p>웹 서비스 인프라를 구성할 때 트래픽 분산, 캐싱 등을 위해 프록시를 배치하게 되는데 이 프록시와 웹 서버가 서로 HTTP 요청의 Body 길이에 대한 해석을 다르게 하면서 주로 발생합니다. </p><p>Body의 길이는 Content-Length 헤더나 Transfer-Encoding 헤더를 통해 결정되며 아래의 규칙이 존재합니다.</p><ol><li>Content-Length 헤더가 2개 이상 존재하면 400 Bad Request로 처리한다.</li><li>Content-Length 헤더와 Transfer-Encoding 헤더가 동시에 존재하면 Transfer-Encoding을 따른다.</li></ol><p>규칙을 읽어보면 표준에 따르기만 해도 Smuggling이 방지될 것 같습니다.</p><p>하지만 공격자들은 연구 끝에 아래 방법을 사용하여 이를 우회 하였습니다.</p><ol><li>특수한 입력값을 통해 특정 파서의 파싱 결과를 다르게 나오도록 유도하기</li><li>파서의 잘못된 처리로직을 이용하기</li></ol><h2 class="anchor anchorWithStickyNavbar_mojV" id="공격-사례">공격 사례<a class="hash-link" href="#공격-사례" title="Direct link to heading">​</a></h2><p>편의를 위해 Content-Length를 CL, Transfer-Encoding을 TE라고 부르겠습니다. </p><h3 class="anchor anchorWithStickyNavbar_mojV" id="cl-cl--특정-파서의-파싱-결과를-다르게-나오도록-유도하기">CL-CL + 특정 파서의 파싱 결과를 다르게 나오도록 유도하기<a class="hash-link" href="#cl-cl--특정-파서의-파싱-결과를-다르게-나오도록-유도하기" title="Direct link to heading">​</a></h3><p>HAProxy는 고가용성(HA)을 위해 주로 사용되는 프록시 입니다.</p><p>작년 9월에 이 프록시에서 CL-CL 유형의 HTTP Request Smuggling이 발견되었습니다.</p><p>해당 유형이 동작하려면 두 파싱 단계에서 400 bad request 처리를 막아야합니다.</p><p>즉 처리하는 순간에는 CL 헤더는 하나만 있는 것으로 보여야 합니다.</p><p>해당 취약 버젼에서 HAProxy는 파싱단계에서 CL이 한번 정상적으로 처리되면 나머지 헤더는 무시하도록 프로그래밍 되어 있습니다.</p><p>그렇기에 HAProxy가 웹 서버로 전달하는 HTTP 요청에는 CL 헤더가 하나만 존재하게 됩니다.</p><p>지금까지의 내용을 정리하면 대략 아래와 같은 방식으로 공격을 진행하면 됩니다.</p><p><img loading="lazy" src="/assets/images/attack_flow-fcd6bf53a3235fbc01b1fbf673f1220b.png" width="2522" height="452" class="img_E7b_"></p><p>그럼 이제 HAProxy가 전달받은 HTTP 요청이 400 Bad Request가 안 뜨면서 두 번째 요청의 CL 헤더의 값과 다르게 하려면 어떻게 해야 할까요?</p><p>HAProxy가 파싱과정에서 비정상 헤더를 정상으로 만들면 됩니다.</p><p>HAProxy는 HTTP 요청을 파싱할 때 HTX라는 구조를 사용합니다.</p><p>HTX는 크게 실제 데이터가 들어있는 payload와 해당 정보를 저장하는 block으로 나뉩니다.</p><p>block에는 이 정보가 어떤 payload의 것인지 주소를 저장하는 부분과 해당 payload의 정보를 저장하는 부분으로 나뉩니다.</p><p>HTX_BLOCK 구조의 두 멤버는 모두 uint32 (4byte) 자료형을 쓰고 있습니다.</p><p><img loading="lazy" src="/assets/images/htx_t-3e6d69f2d2f4a7851853669950be2181.png" width="3668" height="1723" class="img_E7b_"></p><p>payload의 정보를 저장하는 부분을 보면 헤더의 길이를 저장하는 공간이 1byte인 것을 알 수 있습니다.</p><p>정상적인 헤더 중 1byte(256)을 넘는 길이를 가지는 것은 없기 때문에 문제가 없어보입니다.</p><p>실제로 아래와 같이 주석만 남겨두고 길이 검증 코드가 존재하지 않았습니다.</p><div class="codeBlockContainer_I0IT language-c theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-c codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> *  HEAD : 3d5f19e04d88e7c8f71cba4ea12e383c91de89f6</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> *  PATH : include/haproxy/htx.h</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> */</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">static</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">inline</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">htx_blk</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token function" style="color:#d73a49">htx_add_header</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">htx</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">htx</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">ist</span><span class="token plain"> name</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">ist</span><span class="token plain"> value</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">htx_blk</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">blk</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">/* FIXME: check name.len (&lt; 256B) and value.len (&lt; 1MB) */</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    blk </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">htx_add_blk</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">htx</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> HTX_BLK_HDR</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> name</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">len </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> value</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">len</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>이처럼 미흡한 검증은 공격에 쓰이는 좋은 가젯이 됩니다. </p><p>Integer Overflow를 통해 정상 헤더 + dummy 구조의 헤더에서 정상 부분만 처리하도록 하면 우리는 비정상 헤더를 정상으로 보이게 할 수 있습니다.</p><p>HTX를 파싱할 때 헤더의 길이는 구분자 <code>:</code> 앞까지로 계산됩니다.</p><div class="codeBlockContainer_I0IT language-http theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-http codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">POST / HTTP/1.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Length0aaaa..255개..aa: --- (1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Length: 4 --- (2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CLCL</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>(1)에서 헤더의 길이는 270입니다.</p><p>그런데 270은 <code>0b100001110</code> 인데 공간은 8bit만 할당되어 있으므로 앞에 1은 짤려서 <code>0b00001110</code> 만 저장되게 됩니다.</p><p>그렇게 조작된 길이 14만큼 읽으면 정상 헤더인 <code>Content-Length</code>로 바뀌게 됩니다.</p><p>앞서 설명한 부분들을 정리하면 아래의 순서로 Smuggling이 발생합니다.</p><ol><li><p>해당 패킷을 HAProxy가 받을 때는 (1)은 비정상 헤더로 처리되고 (2)를 기준으로 처리</p></li><li><p>HTX 구조로 파싱할 때 Integer Overflow로 인해 (1)이 정상 헤더로 처리</p></li><li><p>HAProxy가 웹 서버에 전달할 때는 (1)이 해당 요청이 다음과 같이 바뀌어 전달</p><div class="codeBlockContainer_I0IT language-http theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-http codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">POST / HTTP/1.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Length:0 --- (1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CLCL</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></li><li><p>Content-Length만큼 처리 후 남은 CLCL이 다음 리퀘스트에 삽입됨</p></li></ol><p>이 취약점은 당연히 아래와 같이 길이 검사를 추가하는 방향으로 패치되었습니다.</p><div class="codeBlockContainer_I0IT language-diff theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-diff codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token inserted-sign inserted prefix inserted" style="color:#36acaa">+</span><span class="token inserted-sign inserted line" style="color:#36acaa"> if (name.len &gt; 255 || value.len &gt; 1048575)</span><br></span><span class="token-line" style="color:#393A34"><span class="token inserted-sign inserted line" style="color:#36acaa"></span><span class="token inserted-sign inserted prefix inserted" style="color:#36acaa">+</span><span class="token inserted-sign inserted line" style="color:#36acaa">     return NULL;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="cl-te--파서의-잘못된-처리-로직-이용하기">CL-TE + 파서의 잘못된 처리 로직 이용하기<a class="hash-link" href="#cl-te--파서의-잘못된-처리-로직-이용하기" title="Direct link to heading">​</a></h3><p>Tomcat은 JSP를 처리하는 Web Application Server 입니다.</p><p>작년 7월에 tomcat에서 CL-TE 유형의 HTTP Request Smuggling 취약점이 발견되었습니다.</p><p>해당 버젼에서 Client가 HTTP/1.0 응답만 받아들이도록 선언되어 있으면 Tomcat이 TE 헤더를 무시하는 로직이 존재하였고 결과적으로 아래와 같이 동작하였습니다.</p><p><img loading="lazy" alt="image-20220303173216629" src="/assets/images/cl_te_attack_flow-dcde0f8fd5dbc7cd8f67c3df756bcaf7.png" width="2522" height="452" class="img_E7b_"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="마치며">마치며<a class="hash-link" href="#마치며" title="Direct link to heading">​</a></h2><p>HTTP Request Smuggling은 처리 방식이 동기화되지 않았다고 하여 HTTP Desync Attack이라고도 불립니다. </p><p>DEFCON 대회 예선 문제로 해당 취약점을 이용한 문제가 출제된 바 있으니 풀어보시면 이해하시는 데 도움이 되실 겁니다.</p><p><a href="https://archive.ooo/c/uploooadit/351/" target="_blank" rel="noopener noreferrer">uploooadit | OOO archive | DEF CON CTF</a></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="reference">Reference<a class="hash-link" href="#reference" title="Direct link to heading">​</a></h3><ul><li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-33037" target="_blank" rel="noopener noreferrer">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-33037</a></li><li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-40346" target="_blank" rel="noopener noreferrer">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-40346</a></li><li><a href="https://github.com/haproxy/haproxy/commit/3b69886f7dcc3cfb3d166309018e6cfec9ce2c95#diff-8420c19f30c823a2c9cbe3ee5d35cf31550110b38fe767b620880f9cd82cecc8" target="_blank" rel="noopener noreferrer">https://github.com/haproxy/haproxy/commit/3b69886f7dcc3cfb3d166309018e6cfec9ce2c95#diff-8420c19f30c823a2c9cbe3ee5d35cf31550110b38fe767b620880f9cd82cecc8</a></li></ul>]]></content>
        <author>
            <name>SYRU</name>
            <uri>https://github.com/l0vey0u</uri>
        </author>
        <category label="research" term="research"/>
        <category label="http" term="http"/>
        <category label="http smuggling" term="http smuggling"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Research] 재밌는 HTTP Request Smuggling 이야기 (1)]]></title>
        <id>/funny-smuggling-story-pt1</id>
        <link href="https://www.syru.dev/blog/funny-smuggling-story-pt1"/>
        <updated>2022-02-06T18:00:00.000Z</updated>
        <summary type="html"><![CDATA[안녕하세요 : ) 시루입니다.]]></summary>
        <content type="html"><![CDATA[<p>안녕하세요 : ) 시루입니다.</p><p>오늘은 간단한 원리지만 불특정 다수에게 피해를 줄 수 있는 공격기법을 가져왔습니다.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="결과물이-제-요청과-달라요">결과물이 제 요청과 달라요<a class="hash-link" href="#결과물이-제-요청과-달라요" title="Direct link to heading">​</a></h3><p>설명을 위해 라벨기를 가져왔습니다. 이 라벨기는 문장과 길이를 입력하면 길이만큼 잘라 줍니다.</p><p>장난꾸러기 시루가 “시루반”이라는 문장을 입력해놓고 두 글자만 입력했다고 하면 어떻게 될까요?</p><p><img loading="lazy" alt="label printer image for prologue" src="/assets/images/label_printer_for_prologue-f0752a10bb8eaa0663f5c9e803b76b9a.png" width="2258" height="935" class="img_E7b_"></p><p>그다음 입력이었던 “민초단” 라벨이 “반민초”가 되어버렸습니다...!</p><p>이는 시루의 요청을 처리한 후 남은 ‘반’이라는 글자가 다음 요청에 포함되어 발생한 것입니다.</p><p>이런 일이 웹 서비스에서도 발생할 수 있습니다. 이번 글에서는 나의 요청이 타인에게 영향을 줄 수 있는 HTTP Request Smuggling을 알아보겠습니다.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="http-request-smuggling">HTTP Request Smuggling<a class="hash-link" href="#http-request-smuggling" title="Direct link to heading">​</a></h2><blockquote><p>HTTP 요청에 대한 일관성 없는 해석</p></blockquote><p><a href="https://cwe.mitre.org/data/definitions/444.html" target="_blank" rel="noopener noreferrer">CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')</a></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="동일한-tcp-connection에서-여러개의-http-message가-처리된-사연">동일한 TCP Connection에서 여러개의 HTTP Message가 처리된 사연<a class="hash-link" href="#동일한-tcp-connection에서-여러개의-http-message가-처리된-사연" title="Direct link to heading">​</a></h3><p>HTTP 프로토콜은 TCP 통신 위에서 동작합니다.</p><p>(UDP를 사용하는 HTTP 3는 이 글에선 언급하지 않겠습니다.)</p><p>TCP 통신은 신뢰할 수 있는 통신을 위해 여러 정보를 공유하는 3way handshake과정을 거칩니다.</p><p>HTTP 통신을 할 때마다 TCP 통신을 새로 해야 한다면 당연히 그만큼 handshake도 해야 하게 됩니다.</p><p>이 시간을 최대한 줄이기 위해 HTTP는 기존에 만들어진 TCP 통신을 사용하게 되었습니다.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="http에서-body-정보를-얻는-방법">HTTP에서 Body 정보를 얻는 방법<a class="hash-link" href="#http에서-body-정보를-얻는-방법" title="Direct link to heading">​</a></h3><p><a href="https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.3" target="_blank" rel="noopener noreferrer">RFC 문서</a>에 따르면 Body의 길이는 다음 규칙을 따릅니다.</p><ul><li>Transfer-Encoding 헤더가 존재하고 chunked transfer coding으로 전달될 때 transfer coding이 data 전송이 끝났음을 가리킬 때까지의 길이로 결정</li><li>Transfer-Encoding 헤더가 존재하지 않고 유효한 Content-Length 헤더가 존재할 때 해당 헤더의 값으로 결정</li><li>Transfer-Encoding 헤더와 Content-Length 헤더가 모두 존재하면 Content-Length 헤더 무시</li><li>Content-Length 헤더가 여러 개 있으면 400 Bad Request 처리</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="라벨기가-웹-서비스였다면">라벨기가 웹 서비스였다면<a class="hash-link" href="#라벨기가-웹-서비스였다면" title="Direct link to heading">​</a></h3><p>라벨기 이야기를 웹 서비스로 확장 시켜보겠습니다.</p><p>라벨기 입력은 완료를 누를 때까지 입력하니 Transfer-Encoding 방식이 어울리고 라벨 커터는 입력받은 길이만큼 자르니 Content-Length가 어울리겠네요</p><p>라벨기에 문장을 입력하고 자르는 과정은 아래와 같이 표현할 수 있습니다.</p><p><img loading="lazy" alt="packet diagram" src="/assets/images/packet_diagram-dadce470f75fb9b1e3a3f4b220ba2dcf.png" width="2621" height="1271" class="img_E7b_"></p><p>라벨 요청에 대한 응답은 아래와 같이 표현할 수 있습니다.</p><p><img loading="lazy" alt="simplified stream" src="data:image/png;base64,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" width="1664" height="154" class="img_E7b_"></p><p>이렇게 된 원인이 무엇일까요? 우선 동일한 라벨카트리지(TCP 커넥션)에서 처리되었고 라벨기에서는 문자열의 끝(Transfer-Encoding)이 기준이였지만 라벨 커터에서는 길이로 입력한 값(Content-Length)이 기준이였기 때문입니다. </p><p>라벨 커터는 앞서 설명드린 규칙을 어긴 예시라고 볼 수도 있겠네요</p><p>이러한 방식으로 다른 요청에 삽입되어 해당 요청을 사용할 수 없게 하거나 완전히 다른 요청으로 바꿔버릴 수 있는 공격이 바로 <strong>HTTP Request Smuggling</strong>입니다.</p><p>이 공격기법은 유형이 크게 두 가지로 나뉩니다.</p><p>Content-Length 헤더 중복 문제 이하 CL-CL이라 부르는 유형과 Transfer-Encoding, Content-Length 헤더 혼동 문제 이하 CL-TE라고 부르는 유형입니다.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="그냥-표준만-따르면-되는-것-아닌가요">그냥 표준만 따르면 되는 것 아닌가요?<a class="hash-link" href="#그냥-표준만-따르면-되는-것-아닌가요" title="Direct link to heading">​</a></h3><p>맞습니다. 처리하는 주체들이 모두 동일한 기준으로 처리하면 됩니다.</p><p>하지만 최근 공격 유형은 요청을 파싱할 때 특정 헤더를 인식하지 못하도록 특수문자를 삽입하거나 다른 내용으로 인식하도록 Buffer Overflow 기법을 사용하는 등 규칙만 따라서는 대응하기 어려운 것이 많습니다.</p><p>표준을 따르는 것 외에도 기본적인 길이 검증이나 특수문자 처리등을 신경써야 합니다.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="마치며">마치며<a class="hash-link" href="#마치며" title="Direct link to heading">​</a></h2><p>다음 포스트에서는 실제로 취약점이 발생한 사례를 공격 유형별로 다뤄보겠습니다.</p>]]></content>
        <author>
            <name>SYRU</name>
            <uri>https://github.com/l0vey0u</uri>
        </author>
        <category label="research" term="research"/>
        <category label="http" term="http"/>
        <category label="http smuggling" term="http smuggling"/>
    </entry>
</feed>