<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="rss.xsl"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>시루의 하루들 Blog</title>
        <link>https://leak.syru.dev/blog</link>
        <description>시루의 하루들 Blog</description>
        <lastBuildDate>Mon, 18 Apr 2022 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Docusaurus 삽질 기록]]></title>
            <link>https://leak.syru.dev/blog/memo_docusaurus</link>
            <guid>https://leak.syru.dev/blog/memo_docusaurus</guid>
            <pubDate>Mon, 18 Apr 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[현재 이 사이트의 엔진인 Docusaurus를 사용하면서 한 많은 삽질을 기록할 예정이다.]]></description>
            <content:encoded><![CDATA[<p>현재 이 사이트의 엔진인 Docusaurus를 사용하면서 한 많은 삽질을 기록할 예정이다.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="blog-글-전체를-보여줄-필요는-없는데">Blog 글 전체를 보여줄 필요는 없는데...!<a href="https://leak.syru.dev/blog/memo_docusaurus#blog-%EA%B8%80-%EC%A0%84%EC%B2%B4%EB%A5%BC-%EB%B3%B4%EC%97%AC%EC%A4%84-%ED%95%84%EC%9A%94%EB%8A%94-%EC%97%86%EB%8A%94%EB%8D%B0" class="hash-link" aria-label="Direct link to Blog 글 전체를 보여줄 필요는 없는데...!" title="Direct link to Blog 글 전체를 보여줄 필요는 없는데...!" translate="no">​</a></h3>
<div class="language-html codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-html codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">&lt;!--truncate--&gt;</span><br></span></code></pre></div></div>
<p>해당 태그를 삽입하면 블로그 글 목록과 그 내용이 출력될 때 이 태그 위까지를 미리보기 형태로 제공하며 나머지 내용은 가려진다.</p>]]></content:encoded>
            <category>memo</category>
            <category>docs</category>
            <category>docusaurus</category>
            <category>api</category>
        </item>
        <item>
            <title><![CDATA[웹 다시 살펴보기 (1)]]></title>
            <link>https://leak.syru.dev/blog/re-zero-web-pt1</link>
            <guid>https://leak.syru.dev/blog/re-zero-web-pt1</guid>
            <pubDate>Thu, 07 Apr 2022 18:00:00 GMT</pubDate>
            <description><![CDATA[그 동안 웹 서비스 보안 취약점을 공부하고 활용할 때 마다 내가 웹에 대해 궁금하지만 바빠서 넘어갔던 부분이 많았다.]]></description>
            <content:encoded><![CDATA[<p>그 동안 웹 서비스 보안 취약점을 공부하고 활용할 때 마다 내가 웹에 대해 궁금하지만 바빠서 넘어갔던 부분이 많았다.
이제 좀 여유를 찾아서 궁금증도 해소하면서 웹에 대해 조금 더 이해하는 시간을 가져볼까 한다.
드림핵의 웹 서비스 보안 커리큘럼을 학습하면서 단어나 문장에 생긴 궁금점을 적어두고 이에 대해 알아보고 정리해보는 방식으로 할 생각이다.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="url과-uri">URL과 URI<a href="https://leak.syru.dev/blog/re-zero-web-pt1#url%EA%B3%BC-uri" class="hash-link" aria-label="Direct link to URL과 URI" title="Direct link to URL과 URI" translate="no">​</a></h2>
<p>URL과 URI는 각각 <a href="https://www.rfc-editor.org/rfc/rfc1738" target="_blank" rel="noopener noreferrer" class="">RFC1738</a> 와 <a href="https://www.rfc-editor.org/rfc/rfc3986" target="_blank" rel="noopener noreferrer" class="">RFC3986</a>에 정의되어있다.</p>
<p>어찌보면 같은 의미의 단어가 3개나 (+URN, 실제론 별로 안쓰니 내용엔 포함하지 않겠다) 있고 그것이 계속 유지되었다는 것은 각각이 상징적인 의미를 가지고 있다고 볼 수 있다.
다행히도 <a href="https://www.rfc-editor.org/rfc/rfc3986#section-1.1.3" target="_blank" rel="noopener noreferrer" class="">RFC3986 1.1.3 항목</a>에서 이 내용이 이미 소개되어있다.
URI가 더 포괄적인 Identifier로서의 의미를 가지고 URL과 URN으로 분류될 수 있다. URN은 constant한 name으로서, URL은 locator로서의 의미를 가진다.</p>
<p>URI는 포괄적으로 쓰기 좋은 단어라고 할 때 URL이라고 하면 안되는 URI는 무엇일까? URL을 더 파고들어가보자
URL은 특정 자원의 위치와 접근에 대한 정보를 담은 문자열이다. 특정 자원의 위치를 가리키지 못하면 URL이 아니다. 예를 들어 현재시간을 출력하는 api 주소가 있다고 하자 해당 URI는 URL도 URN도 될 수 없다. 특정 자원과 관련이 없기 때문이다. 이에 따른 논의는 더 될 수 있을 것 같다. 시간이란 것도 자원으로 해석될 수 있다고 본다. 하지만 일반적인 상황에서는 그냥 URI라고 하면 된다.</p>
<p>URN은 무엇인지 궁금해서 chatgpt를 활용해서 살펴보았다. URN은 urn:ietf:rfc:1738과 같이 인터넷 상 문서나 urn:isbn:~ 과 같은 isbn번호 같은 조금은 더 포괄적으로 자원의 이름에 대한 정보로 쓰는 문자열이다. 하지만 일반적으론 잘 안 쓰니 알고만 있으면 될 것 같다.</p>
<hr>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="reference">Reference<a href="https://leak.syru.dev/blog/re-zero-web-pt1#reference" class="hash-link" aria-label="Direct link to Reference" title="Direct link to Reference" translate="no">​</a></h3>
<ul>
<li class=""><a href="https://www.rfc-editor.org/rfc/rfc1738" target="_blank" rel="noopener noreferrer" class="">RFC1738</a></li>
<li class=""><a href="https://www.rfc-editor.org/rfc/rfc3986" target="_blank" rel="noopener noreferrer" class="">RFC3986</a></li>
</ul>]]></content:encoded>
            <category>research</category>
            <category>web</category>
        </item>
        <item>
            <title><![CDATA[재밌는 HTTP Request Smuggling 이야기 (2)]]></title>
            <link>https://leak.syru.dev/blog/funny-smuggling-story-pt2</link>
            <guid>https://leak.syru.dev/blog/funny-smuggling-story-pt2</guid>
            <pubDate>Sun, 06 Mar 2022 18:00:00 GMT</pubDate>
            <description><![CDATA[안녕하세요 : ) 시루입니다.]]></description>
            <content:encoded><![CDATA[<p>안녕하세요 : ) 시루입니다.</p>
<p><a class="" href="https://leak.syru.dev/blog/funny-smuggling-story-pt1">저번 글</a>에서는 HTTP Request Smuggling이 무엇인지에 대해서 알려드렸는데요.</p>
<p>오늘은 우리 주변에 사용되는 프로그램에서 이 기법으로 공격이 가능한 취약점이 발생한 사례를 알아보겠습니다.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="잠깐-http-request-smuggling이-뭐였지">잠깐, HTTP Request Smuggling이 뭐였지?<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt2#%EC%9E%A0%EA%B9%90-http-request-smuggling%EC%9D%B4-%EB%AD%90%EC%98%80%EC%A7%80" class="hash-link" aria-label="Direct link to 잠깐, HTTP Request Smuggling이 뭐였지?" title="Direct link to 잠깐, HTTP Request Smuggling이 뭐였지?" translate="no">​</a></h2>
<p>사례 연구에 앞서 복습을 해봅시다.</p>
<p>이 공격 기법은 HTTP 요청이 처리될 때 이전 요청이 다음 요청에 포함되어 해당 요청의 처리결과를 바꾸는 것이었습니다.</p>
<p>웹 서비스 인프라를 구성할 때 트래픽 분산, 캐싱 등을 위해 프록시를 배치하게 되는데 이 프록시와 웹 서버가 서로 HTTP 요청의 Body 길이에 대한 해석을 다르게 하면서 주로 발생합니다.</p>
<p>Body의 길이는 Content-Length 헤더나 Transfer-Encoding 헤더를 통해 결정되며 아래의 규칙이 존재합니다.</p>
<ol>
<li class="">Content-Length 헤더가 2개 이상 존재하면 400 Bad Request로 처리한다.</li>
<li class="">Content-Length 헤더와 Transfer-Encoding 헤더가 동시에 존재하면 Transfer-Encoding을 따른다.</li>
</ol>
<p>규칙을 읽어보면 표준에 따르기만 해도 Smuggling이 방지될 것 같습니다.</p>
<p>하지만 공격자들은 연구 끝에 아래 방법을 사용하여 이를 우회 하였습니다.</p>
<ol>
<li class="">특수한 입력값을 통해 특정 파서의 파싱 결과를 다르게 나오도록 유도하기</li>
<li class="">파서의 잘못된 처리로직을 이용하기</li>
</ol>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="공격-사례">공격 사례<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt2#%EA%B3%B5%EA%B2%A9-%EC%82%AC%EB%A1%80" class="hash-link" aria-label="Direct link to 공격 사례" title="Direct link to 공격 사례" translate="no">​</a></h2>
<p>편의를 위해 Content-Length를 CL, Transfer-Encoding을 TE라고 부르겠습니다.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="cl-cl--특정-파서의-파싱-결과를-다르게-나오도록-유도하기">CL-CL + 특정 파서의 파싱 결과를 다르게 나오도록 유도하기<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt2#cl-cl--%ED%8A%B9%EC%A0%95-%ED%8C%8C%EC%84%9C%EC%9D%98-%ED%8C%8C%EC%8B%B1-%EA%B2%B0%EA%B3%BC%EB%A5%BC-%EB%8B%A4%EB%A5%B4%EA%B2%8C-%EB%82%98%EC%98%A4%EB%8F%84%EB%A1%9D-%EC%9C%A0%EB%8F%84%ED%95%98%EA%B8%B0" class="hash-link" aria-label="Direct link to CL-CL + 특정 파서의 파싱 결과를 다르게 나오도록 유도하기" title="Direct link to CL-CL + 특정 파서의 파싱 결과를 다르게 나오도록 유도하기" translate="no">​</a></h3>
<p>HAProxy는 고가용성(HA)을 위해 주로 사용되는 프록시 입니다.</p>
<p>작년 9월에 이 프록시에서 CL-CL 유형의 HTTP Request Smuggling이 발견되었습니다.</p>
<p>해당 유형이 동작하려면 두 파싱 단계에서 400 bad request 처리를 막아야합니다.</p>
<p>즉 처리하는 순간에는 CL 헤더는 하나만 있는 것으로 보여야 합니다.</p>
<p>해당 취약 버젼에서 HAProxy는 파싱단계에서 CL이 한번 정상적으로 처리되면 나머지 헤더는 무시하도록 프로그래밍 되어 있습니다.</p>
<p>그렇기에 HAProxy가 웹 서버로 전달하는 HTTP 요청에는 CL 헤더가 하나만 존재하게 됩니다.</p>
<p>지금까지의 내용을 정리하면 대략 아래와 같은 방식으로 공격을 진행하면 됩니다.</p>
<p><img decoding="async" loading="lazy" src="https://leak.syru.dev/assets/images/attack_flow-fcd6bf53a3235fbc01b1fbf673f1220b.png" width="2522" height="452" class="img_ev3q"></p>
<p>그럼 이제 HAProxy가 전달받은 HTTP 요청이 400 Bad Request가 안 뜨면서 두 번째 요청의 CL 헤더의 값과 다르게 하려면 어떻게 해야 할까요?</p>
<p>HAProxy가 파싱과정에서 비정상 헤더를 정상으로 만들면 됩니다.</p>
<p>HAProxy는 HTTP 요청을 파싱할 때 HTX라는 구조를 사용합니다.</p>
<p>HTX는 크게 실제 데이터가 들어있는 payload와 해당 정보를 저장하는 block으로 나뉩니다.</p>
<p>block에는 이 정보가 어떤 payload의 것인지 주소를 저장하는 부분과 해당 payload의 정보를 저장하는 부분으로 나뉩니다.</p>
<p>HTX_BLOCK 구조의 두 멤버는 모두 uint32 (4byte) 자료형을 쓰고 있습니다.</p>
<p><img decoding="async" loading="lazy" src="https://leak.syru.dev/assets/images/htx_t-3e6d69f2d2f4a7851853669950be2181.png" width="3668" height="1723" class="img_ev3q"></p>
<p>payload의 정보를 저장하는 부분을 보면 헤더의 길이를 저장하는 공간이 1byte인 것을 알 수 있습니다.</p>
<p>정상적인 헤더 중 1byte(256)을 넘는 길이를 가지는 것은 없기 때문에 문제가 없어보입니다.</p>
<p>실제로 아래와 같이 주석만 남겨두고 길이 검증 코드가 존재하지 않았습니다.</p>
<div><div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockTitle_OeMC">include/haproxy/htx.h</div><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">loading</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><br></span></code></pre></div></div><div style="font-size:.9em;font-weight:600;color:#0E75DD;text-align:center;padding-bottom:13px;text-decoration:underline" class=""><a href="https://github.com/haproxy/haproxy/blob/3d5f19e04d88e7c8f71cba4ea12e383c91de89f6/include/haproxy/htx.h#L464-L470" target="_blank">View on GitHub</a></div></div>
<p>이처럼 미흡한 검증은 공격에 쓰이는 좋은 가젯이 됩니다.</p>
<p>Integer Overflow를 통해 정상 헤더 + dummy 구조의 헤더에서 정상 부분만 처리하도록 하면 우리는 비정상 헤더를 정상으로 보이게 할 수 있습니다.</p>
<p>HTX를 파싱할 때 헤더의 길이는 구분자 <code>:</code> 앞까지로 계산됩니다.</p>
<div class="language-http codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-http codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">POST / HTTP/1.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Length0aaaa..255개..aa: --- (1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Length: 4 --- (2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CLCL</span><br></span></code></pre></div></div>
<p>(1)에서 헤더의 길이는 270입니다.</p>
<p>그런데 270은 <code>0b100001110</code> 인데 공간은 8bit만 할당되어 있으므로 앞에 1은 짤려서 <code>0b00001110</code> 만 저장되게 됩니다.</p>
<p>그렇게 조작된 길이 14만큼 읽으면 정상 헤더인 <code>Content-Length</code>로 바뀌게 됩니다.</p>
<p>앞서 설명한 부분들을 정리하면 아래의 순서로 Smuggling이 발생합니다.</p>
<ol>
<li class="">
<p>해당 패킷을 HAProxy가 받을 때는 (1)은 비정상 헤더로 처리되고 (2)를 기준으로 처리</p>
</li>
<li class="">
<p>HTX 구조로 파싱할 때 Integer Overflow로 인해 (1)이 정상 헤더로 처리</p>
</li>
<li class="">
<p>HAProxy가 웹 서버에 전달할 때는 (1)이 해당 요청이 다음과 같이 바뀌어 전달</p>
<div class="language-http codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-http codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">POST / HTTP/1.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Length:0 --- (1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CLCL</span><br></span></code></pre></div></div>
</li>
<li class="">
<p>Content-Length만큼 처리 후 남은 CLCL이 다음 리퀘스트에 삽입됨</p>
</li>
</ol>
<p>이 취약점은 당연히 아래와 같이 길이 검사를 추가하는 방향으로 패치되었습니다.</p>
<div class="language-diff codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-diff codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">+ if (name.len &gt; 255 || value.len &gt; 1048575)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+     return NULL;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="cl-te--파서의-잘못된-처리-로직-이용하기">CL-TE + 파서의 잘못된 처리 로직 이용하기<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt2#cl-te--%ED%8C%8C%EC%84%9C%EC%9D%98-%EC%9E%98%EB%AA%BB%EB%90%9C-%EC%B2%98%EB%A6%AC-%EB%A1%9C%EC%A7%81-%EC%9D%B4%EC%9A%A9%ED%95%98%EA%B8%B0" class="hash-link" aria-label="Direct link to CL-TE + 파서의 잘못된 처리 로직 이용하기" title="Direct link to CL-TE + 파서의 잘못된 처리 로직 이용하기" translate="no">​</a></h3>
<p>Tomcat은 JSP를 처리하는 Web Application Server 입니다.</p>
<p>작년 7월에 tomcat에서 CL-TE 유형의 HTTP Request Smuggling 취약점이 발견되었습니다.</p>
<p>해당 버젼에서 Client가 HTTP/1.0 응답만 받아들이도록 선언되어 있으면 Tomcat이 TE 헤더를 무시하는 로직이 존재하였고 결과적으로 아래와 같이 동작하였습니다.</p>
<p><img decoding="async" loading="lazy" alt="image-20220303173216629" src="https://leak.syru.dev/assets/images/cl_te_attack_flow-dcde0f8fd5dbc7cd8f67c3df756bcaf7.png" width="2522" height="452" class="img_ev3q"></p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="마치며">마치며<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt2#%EB%A7%88%EC%B9%98%EB%A9%B0" class="hash-link" aria-label="Direct link to 마치며" title="Direct link to 마치며" translate="no">​</a></h2>
<p>HTTP Request Smuggling은 처리 방식이 동기화되지 않았다고 하여 HTTP Desync Attack이라고도 불립니다.</p>
<p>DEFCON 대회 예선 문제로 해당 취약점을 이용한 문제가 출제된 바 있으니 풀어보시면 이해하시는 데 도움이 되실 겁니다.</p>
<p><a href="https://archive.ooo/c/uploooadit/351/" target="_blank" rel="noopener noreferrer" class="">uploooadit | OOO archive | DEF CON CTF</a></p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="reference">Reference<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt2#reference" class="hash-link" aria-label="Direct link to Reference" title="Direct link to Reference" translate="no">​</a></h3>
<ul>
<li class=""><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-33037" target="_blank" rel="noopener noreferrer" class="">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-33037</a></li>
<li class=""><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-40346" target="_blank" rel="noopener noreferrer" class="">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-40346</a></li>
<li class=""><a href="https://github.com/haproxy/haproxy/commit/3b69886f7dcc3cfb3d166309018e6cfec9ce2c95#diff-8420c19f30c823a2c9cbe3ee5d35cf31550110b38fe767b620880f9cd82cecc8" target="_blank" rel="noopener noreferrer" class="">https://github.com/haproxy/haproxy/commit/3b69886f7dcc3cfb3d166309018e6cfec9ce2c95#diff-8420c19f30c823a2c9cbe3ee5d35cf31550110b38fe767b620880f9cd82cecc8</a></li>
</ul>]]></content:encoded>
            <category>research</category>
            <category>http</category>
            <category>http smuggling</category>
        </item>
        <item>
            <title><![CDATA[사소한 팁 들 정리]]></title>
            <link>https://leak.syru.dev/blog/memo_tips</link>
            <guid>https://leak.syru.dev/blog/memo_tips</guid>
            <pubDate>Fri, 18 Feb 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[nginx - fastapi 구조의 서비스에서 왜 인지 한글 처리가 제대로 되지 않았다.]]></description>
            <content:encoded><![CDATA[<p>nginx - fastapi 구조의 서비스에서 왜 인지 한글 처리가 제대로 되지 않았다.
charset = utf8 설정을 주어도 해결이 되지 않자</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="base64-encoding">Base64 Encoding<a href="https://leak.syru.dev/blog/memo_tips#base64-encoding" class="hash-link" aria-label="Direct link to Base64 Encoding" title="Direct link to Base64 Encoding" translate="no">​</a></h3>
<p>URL 인코딩 후 그 문자열을 base64처리하여 전달해서 해결하였다.</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">encoded_kr </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token dom variable" style="color:#36acaa">window</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">btoa</span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#d73a49">unescape</span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#d73a49">encodeURLComponent</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">kr_str</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre></div></div>
<div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">from</span><span class="token plain"> base64 </span><span class="token keyword" style="color:#00009f">import</span><span class="token plain"> b64decode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">decoded_kr </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> b64decode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">encoded_kr</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">decode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="더-알아보아야-할-점">더 알아보아야 할 점<a href="https://leak.syru.dev/blog/memo_tips#%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EC%95%84%EC%95%BC-%ED%95%A0-%EC%A0%90" class="hash-link" aria-label="Direct link to 더 알아보아야 할 점" title="Direct link to 더 알아보아야 할 점" translate="no">​</a></h3>
<p>client js 에서 전달하는 위치에선 한글이 깨졌는데 fastapi에서 전달하는 방향으론 한글이 안 깨졌다 js 쪽이 문제였나..?</p>]]></content:encoded>
            <category>memo</category>
            <category>tip</category>
        </item>
        <item>
            <title><![CDATA[재밌는 HTTP Request Smuggling 이야기 (1)]]></title>
            <link>https://leak.syru.dev/blog/funny-smuggling-story-pt1</link>
            <guid>https://leak.syru.dev/blog/funny-smuggling-story-pt1</guid>
            <pubDate>Sun, 06 Feb 2022 18:00:00 GMT</pubDate>
            <description><![CDATA[안녕하세요 : ) 시루입니다.]]></description>
            <content:encoded><![CDATA[<p>안녕하세요 : ) 시루입니다.</p>
<p>오늘은 간단한 원리지만 불특정 다수에게 피해를 줄 수 있는 공격기법을 가져왔습니다.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="결과물이-제-요청과-달라요">결과물이 제 요청과 달라요<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt1#%EA%B2%B0%EA%B3%BC%EB%AC%BC%EC%9D%B4-%EC%A0%9C-%EC%9A%94%EC%B2%AD%EA%B3%BC-%EB%8B%AC%EB%9D%BC%EC%9A%94" class="hash-link" aria-label="Direct link to 결과물이 제 요청과 달라요" title="Direct link to 결과물이 제 요청과 달라요" translate="no">​</a></h3>
<p>설명을 위해 라벨기를 가져왔습니다. 이 라벨기는 문장과 길이를 입력하면 길이만큼 잘라 줍니다.</p>
<p>장난꾸러기 시루가 “시루반”이라는 문장을 입력해놓고 두 글자만 입력했다고 하면 어떻게 될까요?</p>
<p><img decoding="async" loading="lazy" alt="label printer image for prologue" src="https://leak.syru.dev/assets/images/label_printer_for_prologue-f0752a10bb8eaa0663f5c9e803b76b9a.png" width="2258" height="935" class="img_ev3q"></p>
<p>그다음 입력이었던 “민초단” 라벨이 “반민초”가 되어버렸습니다...!</p>
<p>이는 시루의 요청을 처리한 후 남은 ‘반’이라는 글자가 다음 요청에 포함되어 발생한 것입니다.</p>
<p>이런 일이 웹 서비스에서도 발생할 수 있습니다. 이번 글에서는 나의 요청이 타인에게 영향을 줄 수 있는 HTTP Request Smuggling을 알아보겠습니다.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="http-request-smuggling">HTTP Request Smuggling<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt1#http-request-smuggling" class="hash-link" aria-label="Direct link to HTTP Request Smuggling" title="Direct link to HTTP Request Smuggling" translate="no">​</a></h2>
<blockquote>
<p>HTTP 요청에 대한 일관성 없는 해석</p>
</blockquote>
<p><a href="https://cwe.mitre.org/data/definitions/444.html" target="_blank" rel="noopener noreferrer" class="">CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')</a></p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="동일한-tcp-connection에서-여러개의-http-message가-처리된-사연">동일한 TCP Connection에서 여러개의 HTTP Message가 처리된 사연<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt1#%EB%8F%99%EC%9D%BC%ED%95%9C-tcp-connection%EC%97%90%EC%84%9C-%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-http-message%EA%B0%80-%EC%B2%98%EB%A6%AC%EB%90%9C-%EC%82%AC%EC%97%B0" class="hash-link" aria-label="Direct link to 동일한 TCP Connection에서 여러개의 HTTP Message가 처리된 사연" title="Direct link to 동일한 TCP Connection에서 여러개의 HTTP Message가 처리된 사연" translate="no">​</a></h3>
<p>HTTP 프로토콜은 TCP 통신 위에서 동작합니다.</p>
<p>(UDP를 사용하는 HTTP 3는 이 글에선 언급하지 않겠습니다.)</p>
<p>TCP 통신은 신뢰할 수 있는 통신을 위해 여러 정보를 공유하는 3way handshake과정을 거칩니다.</p>
<p>HTTP 통신을 할 때마다 TCP 통신을 새로 해야 한다면 당연히 그만큼 handshake도 해야 하게 됩니다.</p>
<p>이 시간을 최대한 줄이기 위해 HTTP는 기존에 만들어진 TCP 통신을 사용하게 되었습니다.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="http에서-body-정보를-얻는-방법">HTTP에서 Body 정보를 얻는 방법<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt1#http%EC%97%90%EC%84%9C-body-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EC%96%BB%EB%8A%94-%EB%B0%A9%EB%B2%95" class="hash-link" aria-label="Direct link to HTTP에서 Body 정보를 얻는 방법" title="Direct link to HTTP에서 Body 정보를 얻는 방법" translate="no">​</a></h3>
<p><a href="https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.3" target="_blank" rel="noopener noreferrer" class="">RFC 문서</a>에 따르면 Body의 길이는 다음 규칙을 따릅니다.</p>
<ul>
<li class="">Transfer-Encoding 헤더가 존재하고 chunked transfer coding으로 전달될 때 transfer coding이 data 전송이 끝났음을 가리킬 때까지의 길이로 결정</li>
<li class="">Transfer-Encoding 헤더가 존재하지 않고 유효한 Content-Length 헤더가 존재할 때 해당 헤더의 값으로 결정</li>
<li class="">Transfer-Encoding 헤더와 Content-Length 헤더가 모두 존재하면 Content-Length 헤더 무시</li>
<li class="">Content-Length 헤더가 여러 개 있으면 400 Bad Request 처리</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="라벨기가-웹-서비스였다면">라벨기가 웹 서비스였다면<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt1#%EB%9D%BC%EB%B2%A8%EA%B8%B0%EA%B0%80-%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%98%80%EB%8B%A4%EB%A9%B4" class="hash-link" aria-label="Direct link to 라벨기가 웹 서비스였다면" title="Direct link to 라벨기가 웹 서비스였다면" translate="no">​</a></h3>
<p>라벨기 이야기를 웹 서비스로 확장 시켜보겠습니다.</p>
<p>라벨기 입력은 완료를 누를 때까지 입력하니 Transfer-Encoding 방식이 어울리고 라벨 커터는 입력받은 길이만큼 자르니 Content-Length가 어울리겠네요</p>
<p>라벨기에 문장을 입력하고 자르는 과정은 아래와 같이 표현할 수 있습니다.</p>
<p><img decoding="async" loading="lazy" alt="packet diagram" src="https://leak.syru.dev/assets/images/packet_diagram-dadce470f75fb9b1e3a3f4b220ba2dcf.png" width="2621" height="1271" class="img_ev3q"></p>
<p>라벨 요청에 대한 응답은 아래와 같이 표현할 수 있습니다.</p>
<p><img decoding="async" loading="lazy" alt="simplified stream" src="data:image/png;base64,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" width="1664" height="154" class="img_ev3q"></p>
<p>이렇게 된 원인이 무엇일까요? 우선 동일한 라벨카트리지(TCP 커넥션)에서 처리되었고 라벨기에서는 문자열의 끝(Transfer-Encoding)이 기준이였지만 라벨 커터에서는 길이로 입력한 값(Content-Length)이 기준이였기 때문입니다.</p>
<p>라벨 커터는 앞서 설명드린 규칙을 어긴 예시라고 볼 수도 있겠네요</p>
<p>이러한 방식으로 다른 요청에 삽입되어 해당 요청을 사용할 수 없게 하거나 완전히 다른 요청으로 바꿔버릴 수 있는 공격이 바로 <strong>HTTP Request Smuggling</strong>입니다.</p>
<p>이 공격기법은 유형이 크게 두 가지로 나뉩니다.</p>
<p>Content-Length 헤더 중복 문제 이하 CL-CL이라 부르는 유형과 Transfer-Encoding, Content-Length 헤더 혼동 문제 이하 CL-TE라고 부르는 유형입니다.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="그냥-표준만-따르면-되는-것-아닌가요">그냥 표준만 따르면 되는 것 아닌가요?<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt1#%EA%B7%B8%EB%83%A5-%ED%91%9C%EC%A4%80%EB%A7%8C-%EB%94%B0%EB%A5%B4%EB%A9%B4-%EB%90%98%EB%8A%94-%EA%B2%83-%EC%95%84%EB%8B%8C%EA%B0%80%EC%9A%94" class="hash-link" aria-label="Direct link to 그냥 표준만 따르면 되는 것 아닌가요?" title="Direct link to 그냥 표준만 따르면 되는 것 아닌가요?" translate="no">​</a></h3>
<p>맞습니다. 처리하는 주체들이 모두 동일한 기준으로 처리하면 됩니다.</p>
<p>하지만 최근 공격 유형은 요청을 파싱할 때 특정 헤더를 인식하지 못하도록 특수문자를 삽입하거나 다른 내용으로 인식하도록 Buffer Overflow 기법을 사용하는 등 규칙만 따라서는 대응하기 어려운 것이 많습니다.</p>
<p>표준을 따르는 것 외에도 기본적인 길이 검증이나 특수문자 처리등을 신경써야 합니다.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="마치며">마치며<a href="https://leak.syru.dev/blog/funny-smuggling-story-pt1#%EB%A7%88%EC%B9%98%EB%A9%B0" class="hash-link" aria-label="Direct link to 마치며" title="Direct link to 마치며" translate="no">​</a></h2>
<p>다음 포스트에서는 실제로 취약점이 발생한 사례를 공격 유형별로 다뤄보겠습니다.</p>]]></content:encoded>
            <category>research</category>
            <category>http</category>
            <category>http smuggling</category>
        </item>
        <item>
            <title><![CDATA[우리가 알고있는 Underflow는 Underflow가 아니다.]]></title>
            <link>https://leak.syru.dev/blog/memo_about_underflow</link>
            <guid>https://leak.syru.dev/blog/memo_about_underflow</guid>
            <pubDate>Sun, 16 Feb 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[잘 알려진 Underflow의 정의]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="잘-알려진-underflow의-정의">잘 알려진 Underflow의 정의<a href="https://leak.syru.dev/blog/memo_about_underflow#%EC%9E%98-%EC%95%8C%EB%A0%A4%EC%A7%84-underflow%EC%9D%98-%EC%A0%95%EC%9D%98" class="hash-link" aria-label="Direct link to 잘 알려진 Underflow의 정의" title="Direct link to 잘 알려진 Underflow의 정의" translate="no">​</a></h3>
<p>자료형이 저장할 수 있는 범위를 <strong>넘어서</strong> 최솟값 보다 작아지면 최댓값 부터 다시 시작되는 현상</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="이-역시-integer-overflow">이 역시 Integer Overflow<a href="https://leak.syru.dev/blog/memo_about_underflow#%EC%9D%B4-%EC%97%AD%EC%8B%9C-integer-overflow" class="hash-link" aria-label="Direct link to 이 역시 Integer Overflow" title="Direct link to 이 역시 Integer Overflow" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 32bit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-2,147,483,648 - 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">= -2,147,483,648 + (~1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0,10000000,00000000,00000000,00000000(2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0,11111111,11111111,11111111,11111111(2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1,01111111,11111111,11111111,11111111(2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">overflow 부분 제외 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">= 2,147,483,648</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="그럼-underflow는-무엇인가">그럼 Underflow는 무엇인가?<a href="https://leak.syru.dev/blog/memo_about_underflow#%EA%B7%B8%EB%9F%BC-underflow%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80" class="hash-link" aria-label="Direct link to 그럼 Underflow는 무엇인가?" title="Direct link to 그럼 Underflow는 무엇인가?" translate="no">​</a></h3>
<p>부동소수점에서 표현 가능 범위보다 작은 0에 가까운 수가 0이 되는 현상</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="integer-underflow">Integer Underflow<a href="https://leak.syru.dev/blog/memo_about_underflow#integer-underflow" class="hash-link" aria-label="Direct link to Integer Underflow" title="Direct link to Integer Underflow" translate="no">​</a></h3>
<p>설명에 편의성을 위해 Floating Underflow, Integer Underflow로 구분하여 Underflow를 쓰기도 한다.</p>]]></content:encoded>
            <category>memo</category>
            <category>term</category>
            <category>underflow</category>
        </item>
    </channel>
</rss>